(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{90:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return d})),n.d(t,"default",(function(){return l}));var i=n(3),a=n(7),r=(n(0),n(110)),o={sidebar_position:1},s={unversionedId:"tutorial-basics/BinarySearch",id:"tutorial-basics/BinarySearch",isDocsHomePage:!1,title:"Binary Search",description:"Algorithm implemented in Rust",source:"@site/docs/tutorial-basics/BinarySearch.md",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/BinarySearch",permalink:"/docs/tutorial-basics/BinarySearch",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/tutorial-basics/BinarySearch.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Tutorial Intro",permalink:"/docs/intro"},next:{title:"Linear Search",permalink:"/docs/tutorial-basics/LinearSearch"}},d=[{value:"Pseudocode",id:"pseudocode",children:[]},{value:"Code",id:"code",children:[]},{value:"Output",id:"output",children:[]}],c={toc:d};function l(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(r.b)("div",{parentName:"div",className:"admonition-heading"},Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",{parentName:"h5",className:"admonition-icon"},Object(r.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},Object(r.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Important ")),Object(r.b)("div",{parentName:"div",className:"admonition-content"},Object(r.b)("p",{parentName:"div"},"Algorithm implemented in Rust"))),Object(r.b)("p",null,"Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty."),Object(r.b)("p",null,"The time complexity of the binary search algorithm is ",Object(r.b)("inlineCode",{parentName:"p"},"O(log n)"),". The best-case time complexity would be O(1) when the central index would directly match the desired value. The worst-case scenario could be the values at either extremity of the list or values not in the list."),Object(r.b)("div",{className:"admonition admonition-danger alert alert--danger"},Object(r.b)("div",{parentName:"div",className:"admonition-heading"},Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",{parentName:"h5",className:"admonition-icon"},Object(r.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},Object(r.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"Important ")),Object(r.b)("div",{parentName:"div",className:"admonition-content"},Object(r.b)("p",{parentName:"div"},"The array needs to be sorted to perform this algorithm"))),Object(r.b)("h2",{id:"pseudocode"},"Pseudocode"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"Step 1 :- Find the middle element \nStep 2 :- Compare the middle element with the key \nStep 3 :- Move to the right or left side of the array \nStep 4 :- Repeat the process until you find the key \n")),Object(r.b)("h2",{id:"code"},"Code"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-rust"},'fn binary_search(key: i32, arr: [i32; 9]) {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while right >= left {\n        let mid = left + (right - left) / 2; // Defining the mid element\n        if arr[mid] == key {\n            // If the element is present at mid itself\n            println!("Element found at index {}", mid);\n            break;\n        } else if arr[mid] > key {\n            // If mid is greater, Then moving to the left sub array\n            right = mid - 1;\n        } else {\n            // If mid is lower, Then moving to the right sub array\n            left = mid + 1;\n        }\n    }\n    if left > right {\n        println!("Element is not present in the array")\n    }\n}\n\nfn main() {\n    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; // Sorted array\n    binary_search(20, arr);\n    binary_search(8, arr);\n}\n')),Object(r.b)("h2",{id:"output"},"Output"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-rust"},"   Compiling algo v0.1.0 (/home/felix/Documentation/Algorithms-Docs-/algo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.27s\n     Running `target/debug/algo`\nElement is not present in the array\nElement found at index 7\n")))}l.isMDXComponent=!0}}]);